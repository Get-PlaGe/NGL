#created on: Nov 21, 2013
package rules

#declare any global variables here
declare ReadSetInfo
	lane : Lane @key
	nbClusterLane : Long @key
	readSet : ReadSet @key
	validSeqPercent : Double
end

declare LaneInfo
	run : Run
	lane : Lane 
	sizeReadSets : Integer 
	readSets : List 
	nbClusterLane : Long
end

#run.treatments.ngsrg.default.percentClusterIlluminaFilter=
#(run.treatments.ngsrg.default.nbClusterIlluminaFilter/run.treatments.ngsrg.default.nbClusterTotal)*100
rule "Calculate average percentClusterFilter for run"
	@nglBI( rg_1 )
	dialect "java"
	salience 600
	no-loop
	when
		$run : Run($treatment : treatments["ngsrg"], $treatment!=null)
		$mapValue : Map() from $treatment.results.values()
		$nbClusterIlluminaFilter : Entry(key=="nbClusterIlluminaFilter") from $mapValue.entrySet()
		$nbClusterTotal : Entry(key=="nbClusterTotal") from $mapValue.entrySet()
		eval((Long)((PropertyValue)$nbClusterTotal.getValue()).getValue()>0)
	then
		Logger.debug("Calculate  percentClusterIlluminaFilter for run "+$run.getCode());
		//Calculate validSeqPercent
		Long nbClusterFilter = (Long)((PropertyValue)$nbClusterIlluminaFilter.getValue()).getValue();
		Long nbTotal = (Long)((PropertyValue)$nbClusterTotal.getValue()).getValue();
		Double percentClusterIlluminaFilter = roundValue((double)nbClusterFilter/nbTotal*100);
		//Create new PropertyValue
		PropertySingleValue propertyPercentClusterFilter = new PropertySingleValue(percentClusterIlluminaFilter);
		$mapValue.put("percentClusterIlluminaFilter", propertyPercentClusterFilter);
		//Update treatment for Run
		MongoDBDAO.updateSet(InstanceConstants.RUN_ILLUMINA_COLL_NAME, $run, "treatments."+$treatment.getCode(), $treatment);
end 

#Create LaneInfo for each lane of a run :
#run : Run
#lane : Lane
#sizeReadSets : run.lanes.readSet.size
#readSets : list of ReadSetInfo
#nbClusterLane : run.lanes.treatments.ngsrg.default.nbClusterInternalAndIlluminaFilter
rule "Initialize LaneInfo"
	@nglBI( rg_1 )
	dialect "java"
	salience 500
	no-loop
	when
		$run : Run()
		$lane : Lane($treatment : treatments["ngsrg"], $treatment!=null,readSetCodes!=null) from $run.lanes
		$mapValue : Map() from $treatment.results.values()
       	$nbClusterLane : Entry(key == "nbClusterInternalAndIlluminaFilter") from $mapValue.entrySet()
	then
		Logger.debug("Create LaneInfo "+$lane.getNumber());
		LaneInfo laneInfo = new LaneInfo($run, $lane, $lane.getReadSetCodes().size(), new ArrayList(),(Long)((PropertyValue)$nbClusterLane.getValue()).getValue());
		insert(laneInfo);
	
end

#Create ReadSetInfo for each ReadSet of a Lane
#lane : Lane
#nbClusterLane : LaneInfo.nbClusterLane (=lane.treatments.ngsrg.default.nbClusterInternalAndIlluminaFilter)
#readSet : ReadSet
#validSeqpercent : null
rule "Get all readSet"
	@nglBI( rg_1 )
	dialect "java"
	salience 400
	no-loop
    when
        $run : Run( )
       	$lane : Lane( $treatment : treatments["ngsrg"], $treatment!=null) from $run.lanes
       	$readSet : String() from $lane.readSetCodes
       	$laneInfo : LaneInfo(lane==$lane);
    then
    	//Get readSet from database to calculate each validSeqPercent per readSet
    	ReadSet readSet = MongoDBDAO.findByCode(InstanceConstants.READSET_ILLUMINA_COLL_NAME, ReadSet.class, $readSet);	
    	ReadSetInfo readSetInfo = new ReadSetInfo($lane,$laneInfo.getNbClusterLane(),readSet);
    	//Update laneInfo
    	$laneInfo.getReadSets().add(readSetInfo);
    	insert(readSetInfo);
    	update($laneInfo);
end

#readSet.treatments.ngsrg.default.validSeqPercent=
#(readSet.treatments.ngsrg.default.nbCluster/lane.treatments.ngsrg.default.nbClusterInternalAndIlluminaFilter)*100
rule "Calculate seqPercent readSet"
	@nglBI( rg_1 )
	dialect "java"
	salience 300
	no-loop
	when
		$readSetInfo : ReadSetInfo($treatment : readSet.treatments["ngsrg"], $treatment!=null, validSeqPercent==null,nbClusterLane>0)
		$mapValue : Map() from $treatment.results.values()
		$nbCluster : Entry(key=="nbCluster") from $mapValue.entrySet()
	then
		//Calculate validSeqPercent
		Long nbClusterReadSet = ((Long)((PropertyValue)$nbCluster.getValue()).getValue());
		Long nbClusterLane = $readSetInfo.getNbClusterLane();
		Double validSeqPercent = roundValue((double)nbClusterReadSet/nbClusterLane*100);
		//Create new PropertyValue
		PropertySingleValue propertyValidSeqPercent = new PropertySingleValue(validSeqPercent);
		$mapValue.put("validSeqPercent", propertyValidSeqPercent);
		//Update treatment for ReadSet in database
		MongoDBDAO.updateSet(InstanceConstants.READSET_ILLUMINA_COLL_NAME, $readSetInfo.getReadSet(), "treatments."+$treatment.getCode(), $treatment);
		$readSetInfo.setValidSeqPercent(validSeqPercent);
		update($readSetInfo);
end

#run.lane.treatments.ngsrg.default.seqLossPercent=
#(100-SOMME(readset.treatments.ngsrg.default.validSeqPercent))
rule "Calculate seqLossPercent Lane"
	@nglBI( rg_1 )
	dialect "java"
	salience 200
	no-loop
	when
		$laneInfo : LaneInfo(sizeReadSets == readSets.size(), $treatment : lane.treatments["ngsrg"], $treatment!=null)
		$mapValue : Map() from $treatment.results.values()
		$sumValidSeqPercent : Double() from accumulate (ReadSetInfo(lane==$laneInfo.lane, validSeqPercent!=null, $value : validSeqPercent), sum($value))
	then
		Double seqLossPercent =roundValue(100-$sumValidSeqPercent);
		//Create new PropertyValue seqLossPercent
		PropertySingleValue propertySeqLossPercent = new PropertySingleValue(seqLossPercent);
		$mapValue.put("seqLossPercent", propertySeqLossPercent);
		//Update treatment for lane 
		MongoDBDAO.update(InstanceConstants.RUN_ILLUMINA_COLL_NAME, Run.class, 
						DBQuery.and(DBQuery.is("code", $laneInfo.getRun().getCode()), DBQuery.is("lanes.number", $laneInfo.getLane().getNumber())),
						DBUpdate.set("lanes.$.treatments."+$treatment.getCode(), $treatment));
end

function Double roundValue(double value)
{
	DecimalFormat df=new DecimalFormat("0.00");
	return (Double)df.parse(df.format(value)).doubleValue();
}